Okay, here is a summary of each page in the document:

*   **Page 1:** Title slide: "Database Systems: Database Storage: Files & Pages" for Carnegie Mellon University's 15-445/645 Spring 2025 course, taught by Prof. Jignesh Patel.
*   **Page 2:** Administrivia: Project #0 due January 26th, Homework #1 due January 29th, Project #1 released January 22nd.
*   **Page 3:** Last Class Summary:  Recap of the logical view of databases and SQL. Preview of learning how to build database management systems (DBMS).
*   **Page 4:** Course Outline: Topics include Relational Databases, Storage, Query Execution, Concurrency Control, Database Recovery, Distributed Databases, Potpourri. Storage module contains: Query Planning, Operator Execution, Access Methods, Buffer Pool Manager, Disk Manager.
*   **Page 5:** Course Outline: Same as above. Includes label of Application.
*   **Page 6:** Course Outline: Same as above. SQL arrow pointing to Application.
*   **Page 7:** Course Outline: Same as above. Storage module is highlighted.
*   **Page 8:** Today's Agenda: Background, File Storage, Page Layout, Tuple Layout.
*   **Page 9:** Disk-Based Architecture: DBMS primarily uses non-volatile disk for storage. DBMS components manage data movement between non-volatile and volatile storage.
*   **Page 10:** Storage Hierarchy: Pyramid showing CPU Registers (fastest, smallest, expensive) to Network Storage (slowest, largest, cheaper).
*   **Page 11:** Storage Hierarchy: Same as page 10. DRAM is labeled Volatile. SSD, HDD, and Network Storage are labeled Non-Volatile.
*   **Page 12:** Storage Hierarchy: Same as page 11. CPU Registers and CPU Caches are grouped under "CPU". DRAM is grouped under "Memory". SSD, HDD, and Network Storage are grouped under "Disk".
*   **Page 13:** Storage Hierarchy: SSD, Fast Network Storage, and HDD in order.
*   **Page 14:** Storage Hierarchy: DRAM, Persistent Memory, SSD, Fast Network Storage, and HDD in order.
*   **Page 15:** Storage Hierarchy: Highlights Persistent Memory.
*   **Page 16:** Storage Hierarchy: Intel ending Optane memory business.
*   **Page 17:** Storage Hierarchy: Dram, CXL Type 3, SSD, Fast Network Storage, and HDD in order.
*   **Page 18:** Storage Hierarchy: CXL Memory Expander
*   **Page 19:** Access Times: Latency numbers from L1 Cache Ref to Tape Archives.
*   **Page 20:** Access Times: Access times converted into seconds, hours, weeks, and years.
*   **Page 21:** Sequential vs. Random Access: Random access is slower than sequential access. DBMS wants to maximize sequential access.
*   **Page 22:** System Design Goals: Manage large databases, avoid performance degradation, maximize sequential access.
*   **Page 23:** Disk-Oriented DBMS: Generic diagram showing "Disk" and "Database File".
*   **Page 24:** Disk-Oriented DBMS: Diagram showing Database File split into Directory and then Pages.
*   **Page 25:** Disk-Oriented DBMS: Buffer Pool and Database File.
*   **Page 26:** Disk-Oriented DBMS: Buffer Pool, Database File, and Execution Engine.
*   **Page 27:** Disk-Oriented DBMS: Execution Engine getting Page #2.
*   **Page 28:** Disk-Oriented DBMS: Page #2 copied into the Buffer Pool.
*   **Page 29:** Disk-Oriented DBMS: Copy of Page #2 in Buffer Pool.
*   **Page 30:** Disk-Oriented DBMS: Pointer to Page #2.
*   **Page 31:** Disk-Oriented DBMS: Interpreting Page #2 layout.
*   **Page 32:** Disk-Oriented DBMS: Updating Page #2.
*   **Page 33:** Disk-Oriented DBMS: All steps included.
*   **Page 34:** Disk-Oriented DBMS: Lectures #3-5
*   **Page 35:** Disk-Oriented DBMS: Lecture #6
*   **Page 36:** Disk-Oriented DBMS: Lectures #13-14
*   **Page 37:** Database Storage Problems: Representing databases on disk (today's topic), and memory management.
*   **Page 38:** File Storage: DBMS stores databases as files, typically in a proprietary format.  Custom filesystems on raw block storage were used in older systems.
*   **Page 39:** File Storage: Oracle Database - ASM diagram.
*   **Page 40:** Storage Manager:  Responsible for managing the database's files, scheduling reads/writes, organizing files into pages, tracking space.
*   **Page 41:** Database Pages: Fixed-size blocks of data, can contain different data types. Each page has a unique ID and DBMS uses an indirection layer to map page IDs to physical locations.
*   **Page 42:** Database Pages: Mentions Hardware, OS, and Database Pages.
*   **Page 43:** Database Pages: Highlights the Database Page (512B-32KB).
*   **Page 44:** Database Pages: Database page sizes for different databases (4KB, 8KB, 16KB).
*   **Page 45:** Page Storage Architecture: Discusses how DBMS manage pages in files: Heap File, Tree File, Sequential/Sorted File, and Hashing File organization.  Doesn't need to know the internal contents yet.
*   **Page 46:** Page Storage Architecture: Highlight on Heap File organization.
*   **Page 47:** Heap File: Unordered collection of pages. Supports CRUD operations and iteration. Needs metadata to track files and free space.
*   **Page 48:** Heap File: Diagram of heap file.
*   **Page 49:** Heap File: Diagram showing calculating offset.
*   **Page 50:** Heap File: Showing several Heap Files.
*   **Page 51:** Heap File: Getting page #23.
*   **Page 52:** Heap File: File location - Page# x PageSize.
*   **Page 53:** Heap File: File location - Page# x PageSize.
*   **Page 54:** Heap File: Page Directory.
*   **Page 55:** Heap File: Page Directory - Shows pointers to pages.
*   **Page 56:** Today's Agenda: File Storage, Page Layout, and Tuple Layout.
*   **Page 57:** Page Header: Every page contains a header of metadata about the page's contents.
*   **Page 58:** Page Layout: How to organize data inside a page (row-oriented).  Tuple-oriented, Log-structured, and Index-organized storage approaches.
*   **Page 59:** Page Layout: Same as page 58.
*   **Page 60:** Page Layout: Same as page 59.
*   **Page 61:** Page Layout: Highlight on Tuple-oriented storage.
*   **Page 62:** Page Layout: Highlight on Index-organized storage.
*   **Page 63:** Tuple-Oriented Storage: Keep track of number of tuples in a page and append to the end.
*   **Page 64:** Tuple-Oriented Storage: Example diagram.
*   **Page 65:** Tuple-Oriented Storage: Deletion causes problems.
*   **Page 66:** Tuple-Oriented Storage: Deletion causes problems.
*   **Page 67:** Tuple-Oriented Storage: Example diagram with added Tuple #4.
*   **Page 68:** Tuple-Oriented Storage: What happens if we have a variable-length attribute.
*   **Page 69:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 70:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 71:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 72:** Slotted Pages: Layout scheme, with tuple slots and pointers.
*   **Page 73:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 74:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 75:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 76:** Slotted Pages: Layout scheme, with tuple slots - Tuple #3 crossed out.
*   **Page 77:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 78:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 79:** Slotted Pages: Layout scheme, with tuple slots.
*   **Page 80:** Record IDs: DBMS assigns each tuple a unique record identifier representing its physical location.
*   **Page 81:** Record IDs: PostGres SQL, SQLite, SQL Server, and Oracle record IDs
*   **Page 82:** Today's Agenda: File Storage, Page Layout, and Tuple Layout.
*   **Page 83:** Tuple Layout: Tuple is a sequence of bytes. The DBMS interprets the types.
*   **Page 84:** Tuple Header: Each tuple has a header with metadata (visibility, NULL flags).
*   **Page 85:** Tuple Data: Attributes stored in the order specified in the table creation.
*   **Page 86:** Denormalized Tuple Data: DBMS can physically denormalize tuples by storing them together. Reduces I/O but makes updates more expensive.
*   **Page 87:** Denormalized Tuple Data: Arrow pointing to table examples.
*   **Page 88:** Denormalized Tuple Data: Example diagram.
*   **Page 89:** Denormalized Tuple Data: SELECT statement example.
*   **Page 90:** Denormalized Tuple Data: Diagram illustrating the data layout after denormalization.
*   **Page 91:** Denormalized Tuple Data: diagram highlighting where foo and bar are.
*   **Page 92:** Denormalized Tuple Data: Diagram highlighting where foo and bar are.
*   **Page 93:** Denormalized Tuple Data: Diagram highlighting where foo and bar are.
*   **Page 94:** Conclusion:  Databases are organized in pages, and there are various ways to track, store, and organize tuples within them.
*   **Page 95:** Next Class:  Log-Structured Storage, Index-Organized Storage, Value Representation, and Catalogs.